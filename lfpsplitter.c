/* lfpsplitter - Splits the .lfp files generated by Lytro's desktop app into
 *  .jpg and .txt files in a hopefully platform independent way
 * 
 * Copyright (c) 2011, Nirav Patel <nrp@eclecti.cc>
 * 
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>
#include "lfpsplitter.h"

#define SHA1_LENGTH 45
#define MAGIC_LENGTH 12
#define BLANK_LENGTH 35
#define STRING_LENGTH 256

// TODO: read directly from the file instead of copying to a string
//       since camera backup files can be in the hundreds of megabytes
static lfp_file_p lfp_create(const char *filename)
{
    FILE *fp;
    lfp_file_p lfp = (lfp_file_p)calloc(1, sizeof(lfp_file_t));
    if (!lfp) {
        return NULL;
    }
    
    if (!(fp = fopen(filename, "r"))) {
        return NULL;
    }
    
    fseek(fp, 0, SEEK_END);
    lfp->len = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    lfp->data = malloc(lfp->len);
    
    lfp->len = fread(lfp->data, 1, lfp->len, fp);
    fclose(fp);
    
    return lfp;
}

static int lfp_file_check(lfp_file_p lfp)
{
    char magic[8] = {0x89, 0x4C, 0x46, 0x50, 0x0D, 0x0A, 0x1A, 0x0A};
    if (lfp->len > sizeof(magic) && memcmp(lfp->data, magic, sizeof(magic)) == 0) return 1;
    return 0;
}

static lfp_section_p parse_section(char **lfp, int *in_len)
{
    char *ptr = *lfp;
    int len = *in_len;
    lfp_section_p section = calloc(1,sizeof(lfp_section_t));
    if (!section) return NULL;
    
    // There may be some null region between sections
    while (*ptr == '\0' && len) {
        ptr++;
        len--;
    }
    
    if (len <= MAGIC_LENGTH+sizeof(uint32_t)+SHA1_LENGTH+BLANK_LENGTH) {
        free(section);
        return NULL;
    }
    
    // Copy the magic type
    memcpy(section->typecode, ptr, 4);
    // Move past the magic and the first 4 bytes of 0s
    ptr += MAGIC_LENGTH;
    len -= MAGIC_LENGTH;
    
    // the length is stored as a big endian unsigned 32 bit int
    section->len = ntohl(*(uint32_t *)ptr);
    ptr += sizeof(uint32_t);
    len -= sizeof(uint32_t);
    
    // copy and move past the sha1 string and the 35 byte empty space
    memcpy(section->sha1, ptr, SHA1_LENGTH);
    ptr += SHA1_LENGTH+BLANK_LENGTH;
    len -= SHA1_LENGTH+BLANK_LENGTH;
    
    // make sure there exists as much data as the header claims
    if (len < section->len) {
        free(section);
        return NULL;
    }
    
    // just directly reference the existing buffer
    section->data = ptr;
    
    ptr += section->len;
    len -= section->len;
    
    *lfp = ptr;
    *in_len = len;
    
    return section;
}

static char *depth_string(const char *data, int *datalen, int len)
{
    // make sure there is enough space for the ascii formatted floats
    int filelen = 20*len/4;
    char *depth = malloc(filelen);
    char *start = depth;
    int i = 0;
    
    if (!depth) return NULL;
    depth[0] = '\0';
    
    for (i = 0; i < len/4; i++) {
        char val[20];
        int vallen = 0;
        snprintf(val, 20, "%f\n",*(float *)(data+i*4));
        vallen = strlen(val);
        strncpy(depth, val, vallen);
        depth += vallen;
    }
    
    *datalen = depth-start;
    
    return start;
}

static char *converted_image(const unsigned char *data, int *datalen, int len)
{
    int filelen = 4*len/3;
    const unsigned char *ptr = data;
    unsigned short *image = malloc(filelen*sizeof(short));
    unsigned short *start = image;
    
    if (!image) return NULL;
    // Turn the 12 bits per pixel packed array into 16 bits per pixel
    // to make it easier to import into other libraries
    while (ptr < data+len) {
        *image++ = (*ptr << 8) | (*(ptr+1) & 0xF0);
        *image++ = ((*(ptr+1) & 0x0F) << 12) | (*(ptr+2) << 4);
        
        ptr += 3;
    }
    
    *datalen = filelen;
    
    return (char *)start;
}

static int save_data(const char *data, int len, const char *filename)
{
    FILE *fp;
    
    if (!(fp = fopen(filename, "wb"))) {
        fprintf(stderr, "Failed to open %s for writing\n", filename);
        return 0;
    }
    
    if (fwrite(data, 1, len, fp) != len) {
        fprintf(stderr, "Failed to write %s\n", filename);
        return 0;
    }
    
    fclose(fp);
    
    return 1;
}

// Try to figure out if the data represents an image, text, raw data, etc
static void lfp_identify_section(lfp_file_p lfp, lfp_section_p section)
{
    char jpeg[10] = {0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46};
    char *ptr = NULL;
    int quotecount = 0;
    section->name = malloc(STRING_LENGTH);

    // Find the sha1 in the table of contents
    if ((ptr = strstr(lfp->table->data, section->sha1))) {
        // Move backwards to the corresponding name
        while (quotecount < 3 && (ptr-- > lfp->table->data))
            if (*ptr == '"') quotecount++;
        
        // Read the name if we can
        if ((!quotecount == 3) || (sscanf(ptr, "\"%255[^\"]\"", section->name) != 1))
            strcpy(section->name, "unknown");
    }
    
    // Hard coded to assume that the 20x20 LUT is 1600 bytes
    if (section->len == 1600) {
        section->type = LFP_DEPTH_LUT;
        strcpy(section->name, "depth");
        return;
    }
    
    // Check for the magic bytes to see if its a jpg
    if ((section->len > sizeof(jpeg)) && 
        (memcmp(section->data, jpeg, sizeof(jpeg)) == 0)) {
        section->type = LFP_JPEG;
        strcpy(section->name, "image");
        return;
    }
    
    // Assume anything that isn't called imageRef is plain text
    if (strcmp(section->name, "imageRef"))
        section->type = LFP_TEXT;
}

static void lfp_parse_sections(lfp_file_p lfp)
{
    char *ptr = lfp->data;
    int len = lfp->len;
    
    // Move past the first header
    ptr += MAGIC_LENGTH+sizeof(uint32_t);
    len -= MAGIC_LENGTH+sizeof(uint32_t);
    
    // Assume the first section is always the table of contents
    lfp->table = parse_section(&ptr, &len);
    lfp->table->type = LFP_TEXT;
    lfp->table->name = "table";
    
    lfp_section_p cur_section = NULL;
    while (len > 0) {
        lfp_section_p new_section = parse_section(&ptr, &len);
        if (!new_section) break;
        
        lfp_identify_section(lfp, new_section);
        
        if (!lfp->sections) lfp->sections = new_section;
        else if (cur_section) cur_section->next = new_section;
        cur_section = new_section;
    }
}

static void lfp_save_sections(lfp_file_p lfp)
{
    char name[STRING_LENGTH];
    lfp_section_p section = lfp->sections;
    int jpeg = 0, raw = 0, text = 0;
    char *buf;
    int buflen = 0;
    
    // Save the plaintext metadata
    snprintf(name, STRING_LENGTH, "%s_%s.txt", lfp->filename, lfp->table->name);
    if (save_data(lfp->table->data, lfp->table->len, name))
        printf("Saved %s\n", name);
    
    while (section != NULL) {
        switch (section->type) {
            case LFP_RAW_IMAGE:
                buf = converted_image((unsigned char *)section->data, &buflen, section->len);
                if (buf) {
                    snprintf(name, STRING_LENGTH, "%s_%s%d.raw", lfp->filename, section->name, raw++);
                    if (save_data(buf, buflen, name))
                        printf("Saved %s\n", name);
                    free(buf);
                }
                break;
            
            case LFP_TEXT:
                snprintf(name, STRING_LENGTH, "%s_%s%d.txt", lfp->filename, section->name, text++);
                if (save_data(section->data, section->len, name))
                    printf("Saved %s\n", name);
                break;
                
            case LFP_DEPTH_LUT:
                // Parse the depth lookup table and save as plaintext
                buf = depth_string(section->data, &buflen, section->len);
                if (buf) {
                    snprintf(name, STRING_LENGTH, "%s_%s.txt", lfp->filename, section->name);
                    if (save_data(buf, buflen, name))
                        printf("Saved %s\n", name);
                    free(buf);
                }
                break;
                
            case LFP_JPEG:
                snprintf(name, STRING_LENGTH, "%s_%.2d.jpg", lfp->filename, jpeg++);
                if (save_data(section->data, section->len, name))
                    printf("Saved %s\n", name);
                break;
        }
        
        section = section->next;
    }
}

static void lfp_close(lfp_file_p lfp)
{
    if (lfp) {
        lfp_section_p section = lfp->sections;
        
        if (lfp->data) free(lfp->data);
        if (lfp->filename) free(lfp->filename);
        while (section) {
            lfp_section_p cur = section;
            section = section->next;
            if (cur->name) free(cur->name);
            free(cur);
        }
        memset(lfp, '\0', sizeof(lfp_file_t));
    }
}

int main(int argc, char *argv[])
{
    char *period = NULL;
    lfp_file_p lfp = NULL;

    if (argc < 2) {
        fprintf(stderr, "Usage: lfpsplitter file.lfp\n");
        return 1;
    }
    
    if (!(lfp = lfp_create(argv[1]))) {
        fprintf(stderr, "Failed to open file %s\n", argv[1]);
        lfp_close(lfp);
        return 1;
    }
    
    if (!lfp_file_check(lfp)) {
        fprintf(stderr, "File %s does not look like an lfp\n", argv[1]);
        lfp_close(lfp);
        return 1;
    }
    
    // save the first part of the filename to name the jpgs later
    if (!(lfp->filename = strdup(argv[1]))) {
        lfp_close(lfp);
        return 1;
    }
    period = strrchr(lfp->filename,'.');
    if (period) *period = '\0';

    lfp_parse_sections(lfp);
    
    lfp_save_sections(lfp);
    
    lfp_close(lfp);
    return 0;
}
